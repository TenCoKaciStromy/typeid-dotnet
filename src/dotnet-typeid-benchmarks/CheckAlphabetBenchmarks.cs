using System.Runtime.CompilerServices;
using BenchmarkDotNet.Attributes;

namespace dotnet_typeid_benchmarks; 

public class CheckAlphabetBenchmarks {
  public static readonly string SomeString = "prefix_01h2xcejqtf2nbrexx3vqjhp41";

  [Params(100_000_000)]
  public long Iterations;
  
  [Benchmark]
  public void RangeCheck() {
    var str = SomeString;
    for (var i = 0; i < Iterations; i++) {
      for (var k = str.Length - 1; k >= 8; k--) {
        _ = IdCharIsValid(str[k]);
      }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IdCharIsValid(char ch)
      => ch is >= '0' and <= '9'
         || ch is >= 'a' and <= 'h'
         || ch is >= 'j' and <= 'k'
         || ch is >= 'm' and <= 'n'
         || ch is >= 'p' and <= 'r'
         || ch is >= 'v' and <= 'z';
  }
  
  [Benchmark]
  public void IfElseCheck() {
    var str = SomeString;
    for (var i = 0; i < Iterations; i++) {
      for (var k = str.Length - 1; k >= 8; k--) {
        _ = IdCharIsValid(str[k]);
      }
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IdCharIsValid(char ch){
      if (ch >= '0' && ch <= '9')
        return true;

      if (ch >= 'a' && ch <= 'z') {
        return ch != 'i'
               && ch != 'l'
               && ch != 'o'
               && ch != 'u';
      }

      return false;
    }
  }
  
  [Benchmark]
  public void AlphabetCheck() {
    var str = SomeString;
    
    for (var i = 0; i < Iterations; i++) {
      for (var k = str.Length - 1; k >= 8; k--) {
        _ = IdCharIsValid(str[k]);
      }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IdCharIsValid(char ch)
      => alphabet.IndexOf(ch) >= 0;
  }
  
  private static readonly string alphabet = "0123456789abcdefghjkmnpqrstvwxyz";

  [Benchmark]
  public void BinaryCheck() {
    var str = SomeString;
    for (var i = 0; i < Iterations; i++) {
      var chars = str.AsMemory().Slice(8).Span;

      _ = AreCharsValid(chars);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool AreCharsValid(ReadOnlySpan<char> chars) {
      Span<byte> inputBytes = stackalloc byte[26];
      if (System.Text.Encoding.UTF8.GetBytes(chars, inputBytes) != 26)
        return false;

      return AllInputBytesAreOk(inputBytes);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool AllInputBytesAreOk(Span<byte> inputBytes)
      => DecBytes is { } decBytes
         && decBytes[inputBytes[0]] != 0xFF
         && decBytes[inputBytes[1]] != 0xFF
         && decBytes[inputBytes[2]] != 0xFF
         && decBytes[inputBytes[3]] != 0xFF
         && decBytes[inputBytes[4]] != 0xFF
         && decBytes[inputBytes[5]] != 0xFF
         && decBytes[inputBytes[6]] != 0xFF
         && decBytes[inputBytes[7]] != 0xFF
         && decBytes[inputBytes[8]] != 0xFF
         && decBytes[inputBytes[9]] != 0xFF
         && decBytes[inputBytes[10]] != 0xFF
         && decBytes[inputBytes[11]] != 0xFF
         && decBytes[inputBytes[12]] != 0xFF
         && decBytes[inputBytes[13]] != 0xFF
         && decBytes[inputBytes[14]] != 0xFF
         && decBytes[inputBytes[15]] != 0xFF
         && decBytes[inputBytes[16]] != 0xFF
         && decBytes[inputBytes[17]] != 0xFF
         && decBytes[inputBytes[18]] != 0xFF
         && decBytes[inputBytes[19]] != 0xFF
         && decBytes[inputBytes[20]] != 0xFF
         && decBytes[inputBytes[21]] != 0xFF
         && decBytes[inputBytes[22]] != 0xFF
         && decBytes[inputBytes[23]] != 0xFF
         && decBytes[inputBytes[24]] != 0xFF
         && decBytes[inputBytes[25]] != 0xFF;
  }
  
  private static readonly byte[] DecBytes = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A, 0x0B, 0x0C,
    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0xFF, 0x12, 0x13, 0xFF, 0x14,
    0x15, 0xFF, 0x16, 0x17, 0x18, 0x19, 0x1A, 0xFF, 0x1B, 0x1C,
    0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
  };
}